// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"database/sql"

	"github.com/AbhinavPalacharla/xtrn-personal/internal/db/models"
)

const deleteAllMCPinstances = `-- name: DeleteAllMCPinstances :exec
DELETE FROM mcp_server_instances
`

func (q *Queries) DeleteAllMCPinstances(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllMCPinstances)
	return err
}

const deleteMCPServerInstance = `-- name: DeleteMCPServerInstance :exec
DELETE FROM mcp_server_instances
WHERE
  id = ?
`

func (q *Queries) DeleteMCPServerInstance(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteMCPServerInstance, id)
	return err
}

const getChatMessages = `-- name: GetChatMessages :many
SELECT
  m.id, m.role, m.content, m.stop_reason, m.chat_id,
  CASE
    WHEN m.role = 'ai' THEN (
      SELECT
        json_group_array(p.part_json)
      FROM
        (
          SELECT
            CASE
              WHEN amp.type = 'text' THEN json_object(
                'type',
                'text',
                'index',
                amp.part_index,
                'text',
                tp.text
              )
              WHEN amp.type = 'function' THEN json_object(
                'type',
                'tool_call',
                'index',
                amp.part_index,
                'tool_call_id',
                tcp.tool_call_id,
                'name',
                tcp.name,
                'arguments',
                tcp.arguments
              )
            END AS part_json
          FROM
            ai_message_parts amp
            LEFT JOIN text_part tp ON tp.message_part_id = amp.id
            AND amp.type = 'text'
            LEFT JOIN tool_call_part tcp ON tcp.message_part_id = amp.id
            AND amp.type = 'function'
          WHERE
            amp.message_id = m.id
          ORDER BY
            amp.part_index,
            amp.id
        ) p
    )
  END AS ai_message,
  CASE
    WHEN m.role = 'tool' THEN (
      SELECT
        json_object(
          'tool_call_id',
          t.tool_call_id,
          'name',
          t.name,
          'content',
          t.content,
          'is_error',
          t.is_error
        )
      FROM
        tool_call_result t
      WHERE
        t.message_id = m.id
    )
  END AS tool_result
FROM
  messages m
WHERE
  m.chat_id = ?
ORDER BY
  m.id
`

type GetChatMessagesRow struct {
	ID         string
	Role       string
	Content    sql.NullString
	StopReason sql.NullString
	ChatID     string
	AiMessage  interface{}
	ToolResult interface{}
}

// *********************************
func (q *Queries) GetChatMessages(ctx context.Context, chatID string) ([]GetChatMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatMessages, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatMessagesRow
	for rows.Next() {
		var i GetChatMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.Content,
			&i.StopReason,
			&i.ChatID,
			&i.AiMessage,
			&i.ToolResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatsWithMessageCount = `-- name: GetChatsWithMessageCount :many
SELECT
  c.id,
  (
    SELECT
      COUNT(*)
    FROM
      messages m
    WHERE
      m.chat_id = c.id
  ) as message_count
FROM
  chats c
WHERE
  c.id IN (
    SELECT
      chat_id
    FROM
      messages
    GROUP BY
      chat_id
    HAVING
      COUNT(*) > 0
  )
ORDER BY
  message_count DESC
`

type GetChatsWithMessageCountRow struct {
	ID           string
	MessageCount int64
}

func (q *Queries) GetChatsWithMessageCount(ctx context.Context) ([]GetChatsWithMessageCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatsWithMessageCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatsWithMessageCountRow
	for rows.Next() {
		var i GetChatsWithMessageCountRow
		if err := rows.Scan(&i.ID, &i.MessageCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMCPServerImage = `-- name: GetMCPServerImage :one
SELECT
  images.id, images.slug, images.version, images.name, images.docker_image, images.type, images.oauth_provider, images.env_schema,
  providers.name as provider_name,
  providers.client_id,
  providers.client_secret
FROM
  mcp_server_images AS images
  LEFT JOIN oauth_providers AS providers ON images.oauth_provider = providers.name
WHERE
  images.id = ?
`

type GetMCPServerImageRow struct {
	ID            string
	Slug          string
	Version       int64
	Name          string
	DockerImage   string
	Type          string
	OauthProvider sql.NullString
	EnvSchema     models.EnvSchema
	ProviderName  sql.NullString
	ClientID      sql.NullString
	ClientSecret  sql.NullString
}

func (q *Queries) GetMCPServerImage(ctx context.Context, id string) (GetMCPServerImageRow, error) {
	row := q.db.QueryRowContext(ctx, getMCPServerImage, id)
	var i GetMCPServerImageRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Version,
		&i.Name,
		&i.DockerImage,
		&i.Type,
		&i.OauthProvider,
		&i.EnvSchema,
		&i.ProviderName,
		&i.ClientID,
		&i.ClientSecret,
	)
	return i, err
}

const getMCPServerInstances = `-- name: GetMCPServerInstances :many
SELECT
  inst.id as instance_id,
  inst.address,
  img.id AS image_id,
  tool.name as tool_name,
  tool.description as tool_desc,
  tool.schema as tool_schema
FROM
  mcp_server_instances inst
  LEFT JOIN mcp_server_images AS img ON inst.slug = img.slug
  AND inst.version = img.version
  LEFT JOIN mcp_server_tools as tool ON img.id = tool.image_id
`

type GetMCPServerInstancesRow struct {
	InstanceID string
	Address    string
	ImageID    sql.NullString
	ToolName   sql.NullString
	ToolDesc   sql.NullString
	ToolSchema sql.NullString
}

func (q *Queries) GetMCPServerInstances(ctx context.Context) ([]GetMCPServerInstancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMCPServerInstances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMCPServerInstancesRow
	for rows.Next() {
		var i GetMCPServerInstancesRow
		if err := rows.Scan(
			&i.InstanceID,
			&i.Address,
			&i.ImageID,
			&i.ToolName,
			&i.ToolDesc,
			&i.ToolSchema,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOauthTokenByProvider = `-- name: GetOauthTokenByProvider :one
SELECT
  id, refresh_token, oauth_provider
FROM
  oauth_tokens
WHERE
  oauth_tokens.oauth_provider = ?
`

func (q *Queries) GetOauthTokenByProvider(ctx context.Context, oauthProvider string) (OauthToken, error) {
	row := q.db.QueryRowContext(ctx, getOauthTokenByProvider, oauthProvider)
	var i OauthToken
	err := row.Scan(&i.ID, &i.RefreshToken, &i.OauthProvider)
	return i, err
}

const getViewChatMessges = `-- name: GetViewChatMessges :many
SELECT
  id, role, content, stop_reason, chat_id, ai_message, tool_result
FROM
  v_get_chat_messages
WHERE
  chat_id = ?
`

func (q *Queries) GetViewChatMessges(ctx context.Context, chatID string) ([]VGetChatMessage, error) {
	rows, err := q.db.QueryContext(ctx, getViewChatMessges, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VGetChatMessage
	for rows.Next() {
		var i VGetChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.Content,
			&i.StopReason,
			&i.ChatID,
			&i.AiMessage,
			&i.ToolResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAIMessagePart = `-- name: InsertAIMessagePart :one
INSERT INTO
  ai_message_parts (type, part_index, message_id)
VALUES
  (?, ?, ?) RETURNING id
`

type InsertAIMessagePartParams struct {
	Type      string
	PartIndex int64
	MessageID string
}

func (q *Queries) InsertAIMessagePart(ctx context.Context, arg InsertAIMessagePartParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertAIMessagePart, arg.Type, arg.PartIndex, arg.MessageID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertChat = `-- name: InsertChat :exec
/*
Chat Queries
*/
INSERT INTO
  chats (id)
VALUES
  (?)
`

// *********************************
func (q *Queries) InsertChat(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, insertChat, id)
	return err
}

const insertMCPServerImage = `-- name: InsertMCPServerImage :exec
/*
MCP Server Image Queries
*/
INSERT INTO
  mcp_server_images (
    id,
    slug,
    version,
    name,
    docker_image,
    type,
    oauth_provider,
    env_schema
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertMCPServerImageParams struct {
	ID            string
	Slug          string
	Version       int64
	Name          string
	DockerImage   string
	Type          string
	OauthProvider sql.NullString
	EnvSchema     models.EnvSchema
}

// *********************************
func (q *Queries) InsertMCPServerImage(ctx context.Context, arg InsertMCPServerImageParams) error {
	_, err := q.db.ExecContext(ctx, insertMCPServerImage,
		arg.ID,
		arg.Slug,
		arg.Version,
		arg.Name,
		arg.DockerImage,
		arg.Type,
		arg.OauthProvider,
		arg.EnvSchema,
	)
	return err
}

const insertMCPServerInstance = `-- name: InsertMCPServerInstance :exec
/*
MCP Server Instance Queries
*/
INSERT INTO
  mcp_server_instances (id, slug, version, address, env)
VALUES
  (?, ?, ?, ?, ?)
`

type InsertMCPServerInstanceParams struct {
	ID      string
	Slug    string
	Version int64
	Address string
	Env     interface{}
}

// *********************************
func (q *Queries) InsertMCPServerInstance(ctx context.Context, arg InsertMCPServerInstanceParams) error {
	_, err := q.db.ExecContext(ctx, insertMCPServerInstance,
		arg.ID,
		arg.Slug,
		arg.Version,
		arg.Address,
		arg.Env,
	)
	return err
}

const insertMCPServerInstanceTool = `-- name: InsertMCPServerInstanceTool :exec
INSERT INTO
  mcp_server_tools (id, name, description, schema, image_id)
VALUES
  (?, ?, ?, ?, ?)
`

type InsertMCPServerInstanceToolParams struct {
	ID          string
	Name        string
	Description sql.NullString
	Schema      string
	ImageID     string
}

func (q *Queries) InsertMCPServerInstanceTool(ctx context.Context, arg InsertMCPServerInstanceToolParams) error {
	_, err := q.db.ExecContext(ctx, insertMCPServerInstanceTool,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Schema,
		arg.ImageID,
	)
	return err
}

const insertMessage = `-- name: InsertMessage :exec
INSERT INTO
  messages (id, role, content, stop_reason, chat_id)
VALUES
  (?, ?, ?, ?, ?)
`

type InsertMessageParams struct {
	ID         string
	Role       string
	Content    sql.NullString
	StopReason sql.NullString
	ChatID     string
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) error {
	_, err := q.db.ExecContext(ctx, insertMessage,
		arg.ID,
		arg.Role,
		arg.Content,
		arg.StopReason,
		arg.ChatID,
	)
	return err
}

const insertOauthProvider = `-- name: InsertOauthProvider :exec
/*
OAUTH token queries
*/
INSERT INTO
  oauth_providers (
    name,
    client_id,
    client_secret,
    callback_url,
    scopes
  )
VALUES
  (?, ?, ?, ?, ?)
`

type InsertOauthProviderParams struct {
	Name         string
	ClientID     string
	ClientSecret string
	CallbackUrl  string
	Scopes       sql.NullString
}

// *********************************
func (q *Queries) InsertOauthProvider(ctx context.Context, arg InsertOauthProviderParams) error {
	_, err := q.db.ExecContext(ctx, insertOauthProvider,
		arg.Name,
		arg.ClientID,
		arg.ClientSecret,
		arg.CallbackUrl,
		arg.Scopes,
	)
	return err
}

const insertOauthToken = `-- name: InsertOauthToken :exec
INSERT INTO
  oauth_tokens (id, refresh_token, oauth_provider)
VALUES
  (?, ?, ?)
`

type InsertOauthTokenParams struct {
	ID            string
	RefreshToken  string
	OauthProvider string
}

func (q *Queries) InsertOauthToken(ctx context.Context, arg InsertOauthTokenParams) error {
	_, err := q.db.ExecContext(ctx, insertOauthToken, arg.ID, arg.RefreshToken, arg.OauthProvider)
	return err
}

const insertTextPart = `-- name: InsertTextPart :exec
INSERT INTO
  text_part (text, message_part_id)
VALUES
  (?, ?)
`

type InsertTextPartParams struct {
	Text          sql.NullString
	MessagePartID int64
}

func (q *Queries) InsertTextPart(ctx context.Context, arg InsertTextPartParams) error {
	_, err := q.db.ExecContext(ctx, insertTextPart, arg.Text, arg.MessagePartID)
	return err
}

const insertToolCallPart = `-- name: InsertToolCallPart :exec
INSERT INTO
  tool_call_part (tool_call_id, name, arguments, message_part_id)
VALUES
  (?, ?, ?, ?)
`

type InsertToolCallPartParams struct {
	ToolCallID    string
	Name          string
	Arguments     string
	MessagePartID int64
}

func (q *Queries) InsertToolCallPart(ctx context.Context, arg InsertToolCallPartParams) error {
	_, err := q.db.ExecContext(ctx, insertToolCallPart,
		arg.ToolCallID,
		arg.Name,
		arg.Arguments,
		arg.MessagePartID,
	)
	return err
}

const insertToolCallResult = `-- name: InsertToolCallResult :exec
INSERT INTO
  tool_call_result (message_id, tool_call_id, name, content, is_error)
VALUES
  (?, ?, ?, ?, ?)
`

type InsertToolCallResultParams struct {
	MessageID  string
	ToolCallID string
	Name       string
	Content    string
	IsError    bool
}

func (q *Queries) InsertToolCallResult(ctx context.Context, arg InsertToolCallResultParams) error {
	_, err := q.db.ExecContext(ctx, insertToolCallResult,
		arg.MessageID,
		arg.ToolCallID,
		arg.Name,
		arg.Content,
		arg.IsError,
	)
	return err
}

const updateOauthTokenByProivder = `-- name: UpdateOauthTokenByProivder :exec
UPDATE oauth_tokens
SET
  refresh_token = ?
WHERE
  oauth_provider = ?
`

type UpdateOauthTokenByProivderParams struct {
	RefreshToken  string
	OauthProvider string
}

func (q *Queries) UpdateOauthTokenByProivder(ctx context.Context, arg UpdateOauthTokenByProivderParams) error {
	_, err := q.db.ExecContext(ctx, updateOauthTokenByProivder, arg.RefreshToken, arg.OauthProvider)
	return err
}
